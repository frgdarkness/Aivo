# Error Fixing with Function Index Integration

> **üîß Intelligent Error Resolution**  
> Systematic error fixing with Function Index analysis and strategic planning

## üéØ Core Mission

**Objective**: Integrate Function Index System into error fixing workflow to ensure comprehensive analysis and strategic resolution of code issues.

### Key Principles

- üîç **Function-First Analysis**: Always analyze function structure before fixing errors
- üö´ **CRITICAL: Function Dependency Check Before Modification**: TUY·ªÜT ƒê·ªêI KH√îNG V·ªòI V√É s·ª≠a ƒë·ªïi function m√† ph·∫£i ra so√°t function ƒë√≥ c√≥ ƒë∆∞·ª£c g·ªçi ·ªü c√°c file kh√°c hay kh√¥ng, tr√°nh tr∆∞·ªùng h·ª£p fix l·ªói file A l·∫°i l·ªói file B do sai c·∫•u tr√∫c function
- üìä **Error Threshold Management**: Strategic planning for multiple errors (>10)
- üéØ **Root Cause Detection**: Identify function-related causes behind errors
- üîÑ **Systematic Resolution**: Structured approach to error fixing

## üö® Error Fixing Workflow

### Phase 1: Initial Error Assessment

**Step 0: Project Context Validation (MANDATORY)**

**Project Context Validation Implementation**

1. **Mismatch Detection Logic**:
   - Analyze error paths against project structure patterns
   - Check language indicators in error messages and file extensions
   - Validate framework consistency with project configuration
   - Detect platform mismatches (Android vs iOS vs Web vs Backend)

2. **Risk Level Calculation**:
   - **Critical**: Platform mismatches (must stop)
   - **High**: Multiple mismatches or framework conflicts
   - **Medium**: Language inconsistencies or single high-severity issue
   - **Low**: Minor path variations within same project type

3. **Detection Patterns**:
   ```javascript
   // Example path patterns for validation
   const pathPatterns = {
     android: ['/app/src/main/', '.kt', '.java'],
     ios: ['/ios/', '.swift', '.xcodeproj'],
     web: ['/src/', '.tsx', '.jsx'],
     backend: ['/api/', '/server/', '.js', '.ts']
   };
   ```

**Project Context Warning System**

```markdown
## üö® Mandatory Project Validation Workflow

### Pre-Error-Fixing Checklist
- [ ] Load current project identity from .project-identity
- [ ] Analyze error patterns for project mismatch indicators
- [ ] Check path compatibility with current project structure
- [ ] Validate language/framework consistency
- [ ] Generate warnings if mismatches detected
- [ ] Require user confirmation for high-risk scenarios

### Warning Display Template

**üö® C·∫¢NH B√ÅO: C√ì TH·ªÇ NH·∫¶M D·ª∞ √ÅN**

**Ph√°t hi·ªán c√°c v·∫•n ƒë·ªÅ sau:**
- ‚ùå ƒê∆∞·ªùng d·∫´n l·ªói: `{errorPath}` kh√¥ng kh·ªõp v·ªõi c·∫•u tr√∫c d·ª± √°n {currentProjectType}
- ‚ùå Ng√¥n ng·ªØ ph√°t hi·ªán: `{detectedLanguage}` kh√°c v·ªõi ng√¥n ng·ªØ ch√≠nh: `{currentLanguages}`
- ‚ùå Framework ph√°t hi·ªán: `{detectedFramework}` kh√¥ng c√≥ trong danh s√°ch: `{currentFrameworks}`
- ‚ùå Platform ph√°t hi·ªán: `{detectedPlatform}` kh√°c v·ªõi platform hi·ªán t·∫°i: `{currentPlatform}`

**Khuy·∫øn ngh·ªã:**
1. üîç Ki·ªÉm tra l·∫°i d·ª± √°n ƒëang l√†m vi·ªác
2. üìÅ X√°c nh·∫≠n ƒë∆∞·ªùng d·∫´n file ch√≠nh x√°c
3. üîß ƒê·∫£m b·∫£o ƒëang s·ª≠ d·ª•ng ƒë√∫ng IDE/workspace
4. üìã So s√°nh v·ªõi .project-identity file

**L·ª±a ch·ªçn c·ªßa b·∫°n:**
- ‚úÖ **Ti·∫øp t·ª•c fix l·ªói** (b·ªè qua c·∫£nh b√°o)
- ‚ùå **D·ª´ng v√† ki·ªÉm tra l·∫°i** (khuy·∫øn ngh·ªã)
- üîÑ **Chuy·ªÉn sang d·ª± √°n ƒë√∫ng**
```

**User Response Handling System**

**User Interaction Protocol for Project Mismatch Warnings**

1. **Warning Display Requirements**:
   - Show risk level with appropriate emoji indicators
   - List all detected project mismatches with specific details
   - Provide clear recommendations for each issue type
   - Present user options in order of safety (safest first)

2. **User Response Options** (in priority order):
   - **üõë STOP & CHECK**: Halt error fixing to verify project (Safest - Recommended)
   - **‚ö†Ô∏è CONTINUE**: Proceed with user acknowledgment of risks
   - **üîÑ SWITCH**: Get suggestions for correct project

3. **Response Processing Logic**:
   ```javascript
   // Example response handling
   switch (userChoice) {
     case 'stop': return { action: 'halt', reason: 'project_verification' };
     case 'continue': return { action: 'proceed', userAcknowledged: true };
     case 'switch': return { action: 'suggest_projects', currentErrors: errors };
   }
   ```

4. **Safety Measures**:
   - Default to safest option (stop) if no clear user input
   - Log all user decisions for audit trail
   - Require explicit acknowledgment for risky choices
   - Provide project switching recommendations based on detected patterns
    message += '2. üìÅ X√°c nh·∫≠n ƒë∆∞·ªùng d·∫´n file ch√≠nh x√°c\n';
    message += '3. üîß ƒê·∫£m b·∫£o ƒëang s·ª≠ d·ª•ng ƒë√∫ng IDE/workspace\n';
    message += '4. üìã So s√°nh v·ªõi .project-identity file\n\n';
    
    message += '**L·ª±a ch·ªçn c·ªßa b·∫°n:**\n';
    message += '1. ‚úÖ Ti·∫øp t·ª•c fix l·ªói (b·ªè qua c·∫£nh b√°o)\n';
    message += '2. ‚ùå D·ª´ng v√† ki·ªÉm tra l·∫°i (khuy·∫øn ngh·ªã)\n';
    message += '3. üîÑ Chuy·ªÉn sang d·ª± √°n ƒë√∫ng\n\n';
    
    return message;
  }
  
  getRiskLevelEmoji(riskLevel) {
    const riskEmojis = {
      low: 'üü¢ Th·∫•p',
      medium: 'üü° Trung b√¨nh',
      high: 'üü† Cao',
      critical: 'üî¥ Nghi√™m tr·ªçng'
    };
    return riskEmojis[riskLevel] || '‚ö™ Kh√¥ng x√°c ƒë·ªãnh';
  }
  
  async getUserResponse() {
    // This would be implemented based on the specific interface
    // For now, return a mock response structure
    return {
      action: 'proceed_ignore_warning', // or 'stop_and_check', 'switch_project'
      targetProject: null, // only for switch_project action
      userMessage: 'User chose to proceed despite warnings'
    };
  }
  
  generateProjectCheckRecommendations(contextAnalysis) {
    const recommendations = [
      'üìã Ki·ªÉm tra file .project-identity trong th∆∞ m·ª•c g·ªëc',
      'üìÅ X√°c nh·∫≠n ƒë∆∞·ªùng d·∫´n workspace hi·ªán t·∫°i',
      'üîç So s√°nh c·∫•u tr√∫c th∆∞ m·ª•c v·ªõi lo·∫°i d·ª± √°n mong ƒë·ª£i'
    ];
    
    // Add specific recommendations based on detected issues
    contextAnalysis.detectedIssues.forEach(issue => {
      switch (issue.type) {
        case 'path_mismatch':
          recommendations.push(`üóÇÔ∏è Ki·ªÉm tra ƒë∆∞·ªùng d·∫´n: ${issue.details.errorPath}`);
          break;
        case 'language_mismatch':
          recommendations.push(`üíª X√°c nh·∫≠n ng√¥n ng·ªØ l·∫≠p tr√¨nh: ${issue.details.detectedLanguage}`);
          break;
        case 'framework_mismatch':
          recommendations.push(`üîß Ki·ªÉm tra framework: ${issue.details.detectedFramework}`);
          break;
        case 'platform_mismatch':
          recommendations.push(`üì± X√°c nh·∫≠n platform: ${issue.details.detectedPlatform}`);
          break;
      }
    });
    
    return recommendations;
  }
}
```

**Integration with Error Fixing Workflow**

**Enhanced Error Fixing Workflow with Project Validation**

1. **Workflow Entry Point**:
   - **Step 0**: Mandatory project context validation (MUST be first)
   - Load current project identity from `.project-identity`
   - Validate project context against error patterns
   - Handle user interaction for project mismatch warnings

2. **Decision Flow Based on User Response**:
   - **PROCEED**: Continue with error fixing + log user acknowledgment
   - **STOP**: Halt workflow + provide project verification steps
   - **SWITCH**: Show project suggestions + guide project switching

3. **Next Steps for Each Decision**:
   ```markdown
   PROCEED ‚Üí Function Index Analysis ‚Üí Error Categorization ‚Üí Strategic Planning ‚Üí Fix Implementation
   STOP ‚Üí Project Verification ‚Üí Re-run Workflow ‚Üí Update .project-identity if needed
   SWITCH ‚Üí Open Correct Project ‚Üí Confirm New Identity ‚Üí Re-run Workflow
   ```

4. **Integration Points**:
   - Pre-commit hooks with project validation
   - CI/CD pipeline integration with context checking
   - IDE extensions with real-time project verification
   - Error tracking systems with project context logging

**Step 1: Error Collection & Categorization**

**Error Assessment Framework**

1. **Error Data Structure**:
   - **ID**: Unique identifier for tracking
   - **Type**: compilation, runtime, logic, performance
   - **Severity**: high, medium, low (based on impact)
   - **Location**: File path and line number
   - **Message**: Original error description
   - **Affected Functions**: List of functions involved
   - **Potential Cause**: Initial diagnosis (e.g., function_signature_mismatch)

2. **Error Statistics Tracking**:
   - Total error count
   - Distribution by type and severity
   - Function-related error percentage
   - Pattern recognition for recurring issues

3. **Categorization Rules**:
   ```markdown
   HIGH SEVERITY: Compilation errors, critical runtime failures, security issues
   MEDIUM SEVERITY: Logic errors, performance issues, deprecated warnings
   LOW SEVERITY: Style issues, minor optimizations, documentation gaps
   ```

**Step 2: Function Index Integration Check**

```markdown
## Mandatory Function Index Analysis

### Pre-Fix Checklist
- [ ] Load current Function Index registry
- [ ] Identify functions involved in errors
- [ ] Check for function signature mismatches
- [ ] Analyze function dependencies
- [ ] Detect potential function conflicts
- [ ] Review caller-callee relationships
```

### Phase 2: Function Structure Analysis

**Step 3: Comprehensive Function Review**

**Function Analysis for Error Context**

1. **Error Context Analysis Process**:
   - Extract functions from error locations (¬±5 lines range)
   - **üî¥ MANDATORY: Cross-File Dependency Check**: Ra so√°t function ƒë√≥ c√≥ ƒë∆∞·ª£c g·ªçi ·ªü c√°c file kh√°c hay kh√¥ng
   - **üìä Caller Impact Assessment**: Ph√¢n t√≠ch t√°c ƒë·ªông ƒë·∫øn t·∫•t c·∫£ caller functions
   - Analyze each function's structure and relationships
   - Categorize issues: signature mismatches, dependency problems, caller issues
   - Generate detailed analysis report with function-error mappings

2. **Function Extraction Logic**:
   - Parse error location (file:line format)
   - Use Function Index to find functions in proximity
   - Include functions that might be indirectly affected
   - Consider call stack and dependency chain

3. **Function Structure Analysis**:
   ```markdown
   For each function, check:
   - **üîç Cross-File Caller Discovery**: T√¨m t·∫•t c·∫£ n∆°i function ƒë∆∞·ª£c g·ªçi
   - **‚ö†Ô∏è Pre-Fix Impact Assessment**: ƒê√°nh gi√° t√°c ƒë·ªông tr∆∞·ªõc khi s·ª≠a
   - Signature consistency (parameters, return types)
   - Dependency availability and versions
   - Caller compatibility and usage patterns
   - Integration with Function Index registry
   - **üö´ Modification Risk Analysis**: Ph√¢n t√≠ch r·ªßi ro khi thay ƒë·ªïi function
   ```

4. **Analysis Output Structure**:
   - **Affected Functions**: List with error associations
   - **Function Conflicts**: Overlapping or competing implementations
   - **Signature Mismatches**: Parameter/return type issues
   - **Dependency Issues**: Missing or broken dependencies
   - **Caller Problems**: Incorrect function usage patterns

**Step 4: Function Discrepancy Detection**

```markdown
## Function Discrepancy Analysis

### Common Function-Related Error Patterns

1. **Function Signature Mismatch**
   - ‚úÖ Check parameter count differences
   - ‚úÖ Verify parameter type mismatches
   - ‚úÖ Identify return type inconsistencies
   - ‚úÖ Detect optional parameter issues

2. **Function Dependency Issues**
   - ‚úÖ Missing function imports
   - ‚úÖ Circular dependency problems
   - ‚úÖ Version conflicts in function libraries
   - ‚úÖ Undefined function references

3. **Function Caller Problems**
   - ‚úÖ Incorrect function invocation
   - ‚úÖ Missing required parameters
   - ‚úÖ Wrong context binding
   - ‚úÖ Async/await mismatches

4. **Function Overloading Conflicts**
   - ‚úÖ Multiple function definitions
   - ‚úÖ Ambiguous function resolution
   - ‚úÖ Inheritance conflicts
   - ‚úÖ Interface implementation issues
```

### Phase 3: Error Threshold Decision

**Step 5: Strategic Planning for Multiple Errors**

**Error Threshold Management**

1. **Error Load Assessment**:
   - Count total errors and function-related errors
   - Calculate estimated fix time based on error complexity
   - Determine appropriate strategy based on error volume

2. **Strategy Decision Matrix**:
   ```markdown
   >10 ERRORS: Strategic Planning Required
   - Strategy: batch_processing
   - Priority: HIGH
   - Approach: Comprehensive fix plan before implementation
   
   5-10 ERRORS: Grouped Fixing
   - Strategy: category_based
   - Priority: MEDIUM  
   - Approach: Group similar errors and fix systematically
   
   <5 ERRORS: Direct Fixing
   - Strategy: sequential
   - Priority: LOW
   - Approach: Fix errors directly with function analysis
   ```

3. **Function-Related Error Detection**:
   - Keywords: function, method, undefined, not a function
   - Parameters: parameter, argument, signature, overload
   - Dependencies: import, export, dependency, reference
   - Use keyword matching to identify function-related issues

**Strategic Planning Template (>10 Errors)**

```markdown
# Error Fixing Strategic Plan

## üìä Error Analysis Summary
- **Total Errors**: {errorCount}
- **Function-Related**: {functionRelatedCount}
- **Critical Errors**: {criticalCount}
- **Estimated Fix Time**: {estimatedTime}

## üéØ Fixing Strategy

### Phase 1: Critical Function Fixes (Priority 1)
- [ ] Fix function signature mismatches
- [ ] Resolve missing function dependencies
- [ ] Address function import/export issues

### Phase 2: Logic & Runtime Fixes (Priority 2)
- [ ] Fix function caller problems
- [ ] Resolve parameter passing issues
- [ ] Address async/await problems

### Phase 3: Performance & Optimization (Priority 3)
- [ ] Optimize function performance issues
- [ ] Clean up redundant function calls
- [ ] Improve function error handling

## üîÑ Execution Plan

### Batch 1: Foundation Fixes (Functions)
**Target**: Resolve all function structure issues
**Timeline**: {batch1Timeline}
**Success Criteria**: All function-related compilation errors resolved

### Batch 2: Integration Fixes
**Target**: Fix function interaction issues
**Timeline**: {batch2Timeline}
**Success Criteria**: All runtime function errors resolved

### Batch 3: Quality & Performance
**Target**: Optimize and clean up
**Timeline**: {batch3Timeline}
**Success Criteria**: All performance and quality issues resolved

## üìã Risk Assessment
- **High Risk**: {highRiskErrors}
- **Medium Risk**: {mediumRiskErrors}
- **Low Risk**: {lowRiskErrors}

## üß™ Testing Strategy
- [ ] Unit tests for fixed functions
- [ ] Integration tests for function interactions
- [ ] Regression tests for critical paths
- [ ] Performance tests for optimized functions
```

### Phase 4: Systematic Error Resolution

**Step 6: Function-Aware Error Fixing**

**Enhanced Error Fixing with Function Context**

1. **Fix Strategy Generation**:
   - **Function Signature Mismatch**: signature_alignment approach
     - Steps: Identify correct signature ‚Üí Update definition ‚Üí Update calls ‚Üí Validate types
     - Safeguards: Backup function, check callers, run tests after changes
   
   - **Missing Dependency**: dependency_resolution approach
     - Steps: Identify missing module ‚Üí Add import ‚Üí Verify availability ‚Üí Test integration
     - Safeguards: Check circular dependencies, validate paths, ensure compatibility
   
   - **Caller Problem**: caller_correction approach
     - Steps: Analyze call context ‚Üí Correct parameters ‚Üí Fix binding ‚Üí Validate returns
     - Safeguards: Preserve functionality, check call sites, maintain error handling

2. **Safety-First Fix Application**:
   - Create safety checkpoint before any changes
   - Apply fixes step-by-step with validation
   - Automatic rollback on failure
   - Comprehensive post-fix validation

3. **Fix Execution Process**:
   ```markdown
   CHECKPOINT ‚Üí STEP-BY-STEP EXECUTION ‚Üí VALIDATION ‚Üí SUCCESS/ROLLBACK
   ```

4. **Function Impact Assessment**:
   - Analyze affected functions and their callers
   - Measure performance impact of changes
   - Document function modifications
   - Update Function Index registry

## üîÑ Integration with Existing Workflows

### Enhanced Pre-Commit Hook with Project Validation

```bash
#!/bin/bash
# Enhanced pre-commit with Function Index error checking and project validation

echo "üîç Running enhanced error analysis with project validation..."

# Project Context Validation First
echo "üìã Validating project context..."
if [ -f ".project-identity" ]; then
  PROJECT_TYPE=$(grep '"projectType"' .project-identity | cut -d'"' -f4)
  MAIN_LANGUAGES=$(grep '"mainLanguages"' .project-identity | cut -d'"' -f4)
  echo "üìã Current project: $PROJECT_TYPE ($MAIN_LANGUAGES)"
else
  echo "‚ö†Ô∏è Warning: .project-identity not found"
fi

# Standard error checks
npm run lint
npm run type-check
npm run test

# Function Index error analysis with project validation
echo "üìä Analyzing function-related errors with project context..."
npm run function-index:error-analysis -- --project-validation

if [ $? -ne 0 ]; then
  echo "‚ùå Function-related errors detected"
  echo "Running enhanced error fixing workflow with project validation..."
  
  # Enhanced error fixing workflow with project validation
  if [ -f ".ai-system/scripts/error-fixing-with-project-validation.sh" ]; then
    ./.ai-system/scripts/error-fixing-with-project-validation.sh
  else
    echo "Please run error fixing workflow before committing"
    exit 1
  fi
fi

# Additional project-specific validations
case "$PROJECT_TYPE" in
  "android")
    echo "ü§ñ Running Android-specific validations..."
    npm run validate:android
    ;;
  "ios")
    echo "üì± Running iOS-specific validations..."
    npm run validate:ios
    ;;
  "web")
    echo "üåê Running Web-specific validations..."
    npm run validate:web
    ;;
  "backend")
    echo "‚öôÔ∏è Running Backend-specific validations..."
    npm run validate:backend
    ;;
esac

echo "‚úÖ All enhanced error checks with project validation passed"
```

### CI/CD Pipeline Integration

```yaml
# Enhanced CI/CD with Function Index error handling
name: Enhanced Error Detection & Fixing

on: [push, pull_request]

jobs:
  error-analysis:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Function Index
        uses: ./.github/actions/setup-function-index
        
      - name: Comprehensive Error Analysis
        run: |
          npm run error-analysis:comprehensive
          npm run function-index:error-correlation
          
      - name: Generate Error Report
        run: npm run error-report:generate
        
      - name: Strategic Planning (if >10 errors)
        run: |
          ERROR_COUNT=$(npm run error-count --silent)
          if [ $ERROR_COUNT -gt 10 ]; then
            npm run error-planning:strategic
            echo "Strategic plan required - blocking deployment"
            exit 1
          fi
          
      - name: Auto-Fix Safe Errors
        run: npm run error-fix:auto-safe
        
      - name: Validation Tests
        run: |
          npm run test:unit
          npm run test:integration
          npm run test:function-index
```

## üìä Error Tracking & Analytics

### Error Pattern Analysis

**Error Pattern Analysis Framework**

1. **Pattern Categories**:
   - **Function Signature Mismatches**: Track frequency, common causes, prevention strategies
   - **Dependency Issues**: Monitor common modules, resolution times, complexity scores
   - **Caller Problems**: Analyze common functions, complexity patterns, fix success rates

2. **Historical Analysis Process**:
   - Categorize each error by type and context
   - Track resolution patterns and success rates
   - Identify recurring issues and root causes
   - Generate prevention strategies

3. **Insight Generation**:
   - Most common error types and their triggers
   - Average resolution times by category
   - Preventable error identification
   - Risk factor analysis and mitigation

4. **Pattern-Based Recommendations**:
   ```markdown
   PATTERN ‚Üí INSIGHT ‚Üí RECOMMENDATION ‚Üí PREVENTION
   ```

### Success Metrics

```markdown
## Error Fixing Success Metrics

### Efficiency Metrics
- **Error Detection Time**: <2 minutes with Function Index
- **Fix Planning Time**: <10 minutes for >10 errors
- **Resolution Success Rate**: >95% with function analysis
- **Regression Prevention**: >90% through function validation

### Quality Metrics
- **Function Structure Accuracy**: 100% after fixes
- **Dependency Integrity**: 100% maintained
- **Caller Compatibility**: 100% preserved
- **Test Coverage**: >90% for fixed functions

### Performance Metrics
- **Batch Fix Efficiency**: 3x faster than individual fixes
- **Strategic Planning ROI**: 50% time savings for large error sets
- **Function Index Overhead**: <5% additional analysis time
- **Overall Fix Quality**: 40% improvement in fix durability
```

## üö® Emergency Error Handling

### Critical Error Response

**Emergency Error Response System**

1. **Critical Error Detection**:
   - Filter errors by severity level (critical vs standard)
   - Prioritize system-breaking issues
   - Fast-track analysis for critical errors

2. **Emergency Function Analysis**:
   - **Core Function Impact**: Identify affected critical functions
   - **System Impact Assessment**: Measure potential system-wide effects
   - **Quick Fix Identification**: Find immediate resolution options
   - **Rollback Planning**: Prepare safety recovery procedures

3. **Emergency Fix Application**:
   - Apply fixes with minimal system disruption
   - Validate system stability after each fix
   - Automatic rollback on failure detection
   - Comprehensive post-fix validation

4. **Emergency Response Flow**:
   ```markdown
   CRITICAL DETECTION ‚Üí RAPID ANALYSIS ‚Üí EMERGENCY FIXES ‚Üí STABILITY CHECK ‚Üí SUCCESS/ROLLBACK
   ```

5. **Safety Measures**:
   - Automatic rollback on stability failure
   - Follow-up validation required
   - System monitoring during emergency fixes
   - Documentation of emergency procedures

## üìö Documentation & Training

### Enhanced Error Fixing Guidelines with Project Validation

```markdown
## Developer Guidelines: Error Fixing with Function Index & Project Validation

### Before You Start (MANDATORY PROJECT VALIDATION)
1. üîç **ALWAYS validate project context first** - Check .project-identity
2. üìã **Verify workspace alignment** - Ensure correct project/IDE
3. üö® **Review project mismatch warnings** - Don't ignore critical alerts
4. ‚úÖ Always run Function Index analysis first
5. ‚úÖ Understand the function context of errors
6. ‚úÖ Check for function-related patterns
7. ‚úÖ Plan strategically for multiple errors (>10)

### Project Mismatch Warning Handling
**When you see project validation warnings:**

#### üü¢ Low Risk (Proceed with caution)
- Minor path variations within same project type
- ‚úÖ Safe to continue with acknowledgment

#### üü° Medium Risk (Review recommended)
- Language/framework inconsistencies
- üîç Double-check project configuration
- ‚úÖ Proceed if confident about project context

#### üü† High Risk (Stop and verify)
- Multiple mismatches detected
- ‚ùå **Recommended**: Stop and verify project
- ‚ö†Ô∏è Only proceed if absolutely certain

#### üî¥ Critical Risk (Must stop)
- Platform mismatch (Android vs iOS vs Web)
- üö´ **MANDATORY**: Stop and switch to correct project
- ‚ùå Do not proceed - high chance of wrong project

### User Response Options

#### ‚úÖ "Ti·∫øp t·ª•c fix l·ªói" (Continue fixing)
- Use when confident about project context
- System will note your acknowledgment
- Error fixing proceeds normally
- **Responsibility**: You acknowledge potential project mismatch

#### ‚ùå "D·ª´ng v√† ki·ªÉm tra l·∫°i" (Stop and verify) - RECOMMENDED
- Use when unsure about project context
- Allows time to verify workspace and configuration
- Prevents potential cross-project contamination
- **Best Practice**: Always choose this when in doubt

#### üîÑ "Chuy·ªÉn sang d·ª± √°n ƒë√∫ng" (Switch to correct project)
- Use when you realize you're in wrong project
- Helps transition to correct workspace
- Preserves error context for correct project
- **Workflow**: Switch ‚Üí Verify ‚Üí Re-run error fixing

### During Error Fixing
1. ‚úÖ Maintain function signature compatibility
2. ‚úÖ Preserve function dependencies
3. ‚úÖ Validate all function callers
4. ‚úÖ Test function interactions
5. üîç **Monitor for cross-project patterns** in errors
6. üìã **Document any project validation overrides**

### After Error Fixing
1. ‚úÖ Run comprehensive function validation
2. ‚úÖ Update Function Index registry
3. ‚úÖ Document function changes
4. ‚úÖ Monitor for regression issues
5. üìã **Update .project-identity if project config changed**
6. üîç **Review any ignored project warnings**

### Enhanced Best Practices
- **Project Safety First**: Always validate project context before fixing
- **Function Safety Second**: Never break existing function contracts
- **Incremental Fixes**: Fix one function issue at a time
- **Comprehensive Testing**: Test all function interactions
- **Documentation**: Document all function modifications and project overrides
- **Cross-Project Awareness**: Be mindful when working on multiple projects
- **Warning Respect**: Take project mismatch warnings seriously

### Emergency Override Protocol
**For urgent production fixes when project validation fails:**

1. üö® **Acknowledge the risk** - Document why override is necessary
2. ‚è∞ **Set time limit** - Plan to verify project context after fix
3. üìù **Document everything** - Record override reason and actions taken
4. üîÑ **Follow up** - Verify project context and update .project-identity
5. üìä **Review impact** - Check if fix affected correct systems

### Quality Assurance Checklist
- [ ] Project context validated before starting
- [ ] Project mismatch warnings reviewed and handled
- [ ] Function Index analysis completed
- [ ] Error patterns analyzed for project consistency
- [ ] Strategic plan created (if >10 errors)
- [ ] Function safety maintained throughout
- [ ] All tests passing after fixes
- [ ] Documentation updated
- [ ] Project validation overrides documented (if any)
```

---

**üîß Error Fixing with Function Index Integration - Systematic, intelligent, and strategic error resolution with comprehensive function analysis.**