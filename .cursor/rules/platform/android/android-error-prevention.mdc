---
description: Android Error Prevention Rules - Quy t·∫Øc ph√≤ng tr√°nh v√† x·ª≠ l√Ω l·ªói Android ph·ªï bi·∫øn d·ª±a tr√™n ph√¢n t√≠ch log th·ª±c t·∫ø. K√≠ch ho·∫°t khi working v·ªõi Android error prevention, error handling, ho·∫∑c Android development troubleshooting.
alwaysApply: false
---

# Android Error Prevention & Resolution Rules

## üî¥ CRITICAL: Mandatory Error Prevention Checklist

### **B·∫ÆT BU·ªòC** - Pre-Code Analysis

Tr∆∞·ªõc khi vi·∫øt b·∫•t k·ª≥ d√≤ng code Android n√†o, AI PH·∫¢I:

1. **Ki·ªÉm tra imports**: ƒê·∫£m b·∫£o t·∫•t c·∫£ dependencies ƒë∆∞·ª£c khai b√°o
2. **X√°c ƒë·ªãnh ki·ªÉu d·ªØ li·ªáu**: Kh√¥ng ƒë·ªÉ Kotlin suy lu·∫≠n ki·ªÉu khi kh√¥ng ch·∫Øc ch·∫Øn
3. **Validate null safety**: X·ª≠ l√Ω nullable types m·ªôt c√°ch r√µ r√†ng
4. **Ki·ªÉm tra method signatures**: ƒê·∫£m b·∫£o tham s·ªë v√† return types kh·ªõp
5. **Verify resource references**: Ki·ªÉm tra R.id, R.string, R.drawable t·ªìn t·∫°i

## üìã Common Android Errors & Solutions

### 1. Type Inference Errors

**L·ªói**: `Cannot infer type for this parameter. Specify it explicitly.`

**‚ùå WRONG:**

```kotlin
val items = listOf() // Kh√¥ng r√µ ki·ªÉu
val callback = { } // Kh√¥ng r√µ signature
```

**‚úÖ CORRECT:**

```kotlin
val items: List<String> = listOf() // Ho·∫∑c listOf<String>()
val callback: (String) -> Unit = { item ->
    // Handle item
}
```

**üîß AI Rules:**

- **B·∫ÆT BU·ªòC** khai b√°o ki·ªÉu r√µ r√†ng cho collections r·ªóng
- **B·∫ÆT BU·ªòC** ƒë·ªãnh nghƒ©a signature cho lambda expressions
- **B·∫ÆT BU·ªòC** s·ª≠ d·ª•ng generic types khi t·∫°o instances

### 2. Unresolved Reference Errors

**L·ªói**: `Unresolved reference: [ComponentName]`

**üîß AI Prevention Rules:**

```kotlin
// B·∫ÆT BU·ªòC: Ki·ªÉm tra imports tr∆∞·ªõc khi s·ª≠ d·ª•ng
import androidx.fragment.app.viewModels
import androidx.databinding.DataBindingUtil
import com.bumptech.glide.Glide

// B·∫ÆT BU·ªòC: Verify R class references
if (resourceExists(R.id.componentId)) {
    findViewById<View>(R.id.componentId)
}

// B·∫ÆT BU·ªòC: Check ViewBinding/DataBinding setup
class MyFragment : Fragment() {
    private var _binding: FragmentMyBinding? = null
    private val binding get() = _binding!!

    override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View {
        _binding = FragmentMyBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

### 3. Null Safety Violations

**L·ªói**: `Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver`

**‚ùå WRONG:**

```kotlin
val user: User? = getUser()
val name = user.name // Compile error
```

**‚úÖ CORRECT:**

```kotlin
val user: User? = getUser()
val name = user?.name ?: "Unknown" // Safe call with default
// Ho·∫∑c
user?.let { safeUser ->
    val name = safeUser.name
    // Use name safely
}
```

**üîß AI Rules:**

- **B·∫ÆT BU·ªòC** s·ª≠ d·ª•ng safe call operator (?.) cho nullable types
- **B·∫ÆT BU·ªòC** cung c·∫•p default values v·ªõi elvis operator (?: )
- **NGHI√äM C·∫§M** s·ª≠ d·ª•ng !! operator tr·ª´ khi 100% ch·∫Øc ch·∫Øn
- **B·∫ÆT BU·ªòC** s·ª≠ d·ª•ng let/run/apply cho null checks ph·ª©c t·∫°p

### 4. Method Signature Mismatches

**L·ªói**: `Argument type mismatch`, `No value passed for parameter`

**üîß AI Prevention Template:**

```kotlin
// B·∫ÆT BU·ªòC: Ki·ªÉm tra method signature tr∆∞·ªõc khi g·ªçi
fun logFoodConsumption(
    foodId: String,
    quantity: Double,
    mealType: MealType,
    date: LocalDate = LocalDate.now(), // Default parameter
    notes: String? = null // Optional parameter
) {
    // Implementation
}

// B·∫ÆT BU·ªòC: G·ªçi v·ªõi ƒë·∫ßy ƒë·ªß required parameters
logFoodConsumption(
    foodId = "food123",
    quantity = 1.5,
    mealType = MealType.BREAKFAST
)
```

### 5. When Expression Completeness

**L·ªói**: `'when' expression must be exhaustive`

**‚úÖ CORRECT Pattern:**

```kotlin
fun handleStatus(status: ApiStatus): String = when (status) {
    ApiStatus.LOADING -> "Loading..."
    ApiStatus.SUCCESS -> "Success"
    ApiStatus.ERROR -> "Error occurred"
    ApiStatus.IDLE -> "Ready"
    // B·∫ÆT BU·ªòC: Lu√¥n c√≥ else cho sealed classes m·ªü r·ªông trong t∆∞∆°ng lai
    else -> "Unknown status"
}

// Ho·∫∑c cho enum classes
fun handleMealType(mealType: MealType): String = when (mealType) {
    MealType.BREAKFAST -> "Breakfast"
    MealType.LUNCH -> "Lunch"
    MealType.DINNER -> "Dinner"
    MealType.SNACK -> "Snack"
    // Kh√¥ng c·∫ßn else cho enum ƒë√£ cover h·∫øt
}
```

### 6. Resource Management Errors

**L·ªói**: Resource not found, `Cannot access 'val File.root: File'`

**üîß AI Prevention Rules:**

```kotlin
// B·∫ÆT BU·ªòC: Ki·ªÉm tra resource t·ªìn t·∫°i
fun loadImage(imageRes: Int) {
    try {
        val drawable = ContextCompat.getDrawable(context, imageRes)
        if (drawable != null) {
            imageView.setImageDrawable(drawable)
        } else {
            // Handle missing resource
            imageView.setImageResource(R.drawable.placeholder)
        }
    } catch (e: Resources.NotFoundException) {
        Timber.e(e, "Resource not found: $imageRes")
        imageView.setImageResource(R.drawable.error_placeholder)
    }
}

// B·∫ÆT BU·ªòC: Safe file operations
fun readFile(file: File): String? {
    return try {
        if (file.exists() && file.canRead()) {
            file.readText()
        } else {
            null
        }
    } catch (e: Exception) {
        Timber.e(e, "Failed to read file: ${file.path}")
        null
    }
}
```

## üõ†Ô∏è AI Code Generation Templates

### Fragment Template with Error Prevention

```kotlin
class SafeFragment : Fragment() {
    private var _binding: FragmentSafeBinding? = null
    private val binding get() = _binding!!

    private val viewModel: SafeViewModel by viewModels()

    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentSafeBinding.inflate(inflater, container, false)
        return binding.root
    }

    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        super.onViewCreated(view, savedInstanceState)
        setupUI()
        observeViewModel()
    }

    private fun setupUI() {
        // B·∫ÆT BU·ªòC: Safe UI setup v·ªõi null checks
        binding.apply {
            button.setOnClickListener {
                handleButtonClick()
            }
        }
    }

    private fun observeViewModel() {
        // B·∫ÆT BU·ªòC: Safe state observation
        viewLifecycleOwner.lifecycleScope.launch {
            viewModel.uiState.collect { state ->
                when (state) {
                    is UiState.Loading -> showLoading()
                    is UiState.Success -> showSuccess(state.data)
                    is UiState.Error -> showError(state.message)
                }
            }
        }
    }

    private fun handleButtonClick() {
        // B·∫ÆT BU·ªòC: Validate input tr∆∞·ªõc khi x·ª≠ l√Ω
        val input = binding.editText.text?.toString()?.trim()
        if (input.isNullOrBlank()) {
            showError("Input cannot be empty")
            return
        }

        viewModel.processInput(input)
    }

    private fun showError(message: String) {
        // B·∫ÆT BU·ªòC: Safe error display
        context?.let { ctx ->
            Toast.makeText(ctx, message, Toast.LENGTH_SHORT).show()
        }
    }

    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

### ViewModel Template with Error Prevention

```kotlin
class SafeViewModel @Inject constructor(
    private val repository: Repository
) : ViewModel() {

    private val _uiState = MutableStateFlow<UiState>(UiState.Loading)
    val uiState: StateFlow<UiState> = _uiState.asStateFlow()

    fun processInput(input: String) {
        // B·∫ÆT BU·ªòC: Validate parameters
        if (input.isBlank()) {
            _uiState.value = UiState.Error("Invalid input")
            return
        }

        viewModelScope.launch {
            _uiState.value = UiState.Loading

            try {
                val result = repository.processData(input)
                _uiState.value = UiState.Success(result)
            } catch (e: Exception) {
                Timber.e(e, "Failed to process input: $input")
                _uiState.value = UiState.Error(
                    e.message ?: "Unknown error occurred"
                )
            }
        }
    }
}

// B·∫ÆT BU·ªòC: Sealed class cho type safety
sealed class UiState {
    object Loading : UiState()
    data class Success(val data: String) : UiState()
    data class Error(val message: String) : UiState()
}
```

## üîç AI Code Review Checklist

### Pre-Generation Checks

- [ ] **Import Analysis**: T·∫•t c·∫£ dependencies c√≥ trong build.gradle?
- [ ] **Type Safety**: C√≥ nullable types n√†o c·∫ßn x·ª≠ l√Ω?
- [ ] **Resource Validation**: T·∫•t c·∫£ R.\* references c√≥ t·ªìn t·∫°i?
- [ ] **Method Signatures**: Parameters v√† return types c√≥ kh·ªõp?

### Post-Generation Validation

- [ ] **Null Safety**: Kh√¥ng c√≥ unsafe null operations
- [ ] **Exception Handling**: Try-catch cho operations c√≥ th·ªÉ fail
- [ ] **Resource Cleanup**: ViewBinding ƒë∆∞·ª£c null trong onDestroyView
- [ ] **Lifecycle Awareness**: Coroutines s·ª≠ d·ª•ng viewLifecycleOwner
- [ ] **When Exhaustiveness**: T·∫•t c·∫£ when expressions c√≥ else ho·∫∑c cover h·∫øt cases

## üö® Emergency Error Resolution

### Quick Fix Commands

```kotlin
// 1. Missing import quick fix
// B·∫ÆT BU·ªòC: Add import khi g·∫∑p unresolved reference
import androidx.lifecycle.viewModelScope
import kotlinx.coroutines.launch

// 2. Type inference quick fix
// B·∫ÆT BU·ªòC: Specify type khi compiler kh√¥ng th·ªÉ infer
val items: List<String> = emptyList()
val callback: (String) -> Unit = { /* handle */ }

// 3. Null safety quick fix
// B·∫ÆT BU·ªòC: Use safe calls
obj?.method() ?: defaultValue

// 4. When expression quick fix
// B·∫ÆT BU·ªòC: Add missing branches
when (value) {
    // existing branches
    else -> { /* handle unknown case */ }
}
```

## üìä Error Prevention Metrics

### AI Performance Targets

- **Type Inference Errors**: 0% (B·∫ÆT BU·ªòC specify types)
- **Unresolved References**: 0% (B·∫ÆT BU·ªòC validate imports)
- **Null Safety Violations**: 0% (B·∫ÆT BU·ªòC use safe calls)
- **Method Signature Mismatches**: 0% (B·∫ÆT BU·ªòC validate parameters)
- **Resource Errors**: < 1% (B·∫ÆT BU·ªòC validate resources)

### Quality Gates

1. **Pre-commit**: Code compiles without errors
2. **Pre-merge**: All tests pass
3. **Pre-release**: No critical issues in static analysis

---

**üî¥ CRITICAL REMINDER**: M·ªçi l·ªói trong log_example.txt ƒë·ªÅu c√≥ th·ªÉ tr√°nh ƒë∆∞·ª£c b·∫±ng c√°ch tu√¢n th·ªß c√°c rules tr√™n. AI PH·∫¢I √°p d·ª•ng 100% c√°c quy t·∫Øc n√†y khi generate Android code.
